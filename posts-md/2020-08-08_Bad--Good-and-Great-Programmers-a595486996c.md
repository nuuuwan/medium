#### Article 255 · August 8, 2020

### Things that CS Courses Don't Teach You

# Bad, Good and Great Programmers

### Phrase-bookers, Pastichers, and Novelists

## The Phrase-Booker

I usually begin an onsite-coding-interview with an easy-difficulty question. Good Coders take a few minutes at most to answer this question. I then ask a medium-difficulty question, and if the candidate gets it right, a hard question.

Then, why do I ask an easy question? To filter out the bad coders. If a coder flunks one of my easy questions, we can end the interview, and save everyone time. On some rare occasions, I do ask a second easy question. For example, when a candidate gives an interesting, but the wrong answer to an easy question. But, as I said, these are rare.

...

One candidate who flunked an easy question asked me why I ask questions like that. When, if in "real-life" if they had to find an answer, they could Google it?

Writing code is like speaking a language. A way of communicating ideas. To both machines and humans. As a tourist might ask "How do I get to the railway station?", the following snippet of code asks a computer, "What is the square root of two?"

```
math.sqrt(2)
```

Now, as you might survive on a Phrase-book while touring a foreign country, one could find answers to easy coding questions by Googling (like finding the square root). And that would be fine if the point of the easy question was to "get the right answer".

Instead, the point of the coding question is to check other things. To see how the coder constructs code. To see how they connect it with different concepts. To see if they can combine it with other pieces of code that they've written in the past.

![Image](https://cdn-images-1.medium.com/max/800/1*lBXQEN_mAkPWQUWQczS0gw.jpeg)

## The Pasticher

"Pastiche" is a work of art that imitates another work of art. It might be complex and elaborate. But it is not original.

A Pasticher is a better coder than a Phrase-Booker. They don't have to Google the answer to an easy (or even medium-difficulty) coding question because they already know the answer. They already know all the data structures and all the algorithms. All the design patterns and programming styles. All the programming languages and technologies.

But then, you might ask, what is wrong with a Pasticher?

Not much. The ideal pasticher that I describe is very useful. Many a technology company would love to hire them.

But they have one flaw. While they are great at Pastiche, they are poor at originality. Real creativity, where they create something new. The pasticher is like the professor of literature, who is unable, nonetheless, to write an original work of their own.

The Phrase-Booker can't solve problems (without Google). The Pasticher can only solve the problems that they know. They can't solve the problems that they don't know.

Now, this might be fine for many software jobs, where most problems are known problems. But if you are to build something original, then you need something better: The Novelist.

![Image](https://cdn-images-1.medium.com/max/800/1*0ZPWC8j42PFjP07XAhKsZQ.jpeg)

## The Novelist

The hard thing about hard-difficulty coding problems is not that they are hard. They are not much harder than medium questions. A good hard question is one that could have many answers. Some mundane and standard. But some ingenious and creative.

The Pasticher gives one of the standard answers to a hard question. It might be right in theory, but wrong in practice. Because the goal of a hard programming question is to test novelty and creativity. Not correctness and standard-ness.

A good pasticher usually earns a hire at a coding interview. But they are reasonably common. A Novelist, on the other hand, is rare. And a novel and imaginative answer to a hard question (which is also the "right" answer), earns a "strong hire" in my book.

We know how to become a Pasticher. It is a matter of learning things, like algorithms and design patterns. But how does one "learn" to be a Novelist?

Here's my step-by-step approach:

* It helps to be a Pasticher first. Just as some of the most celebrated novelists are well-read and familiar with other novelists, it helps to build a solid base in programming theory. In other words, try to be a good programmer before you decide to be a great one. If you don't end-up being a Novelist, you'll at least be a Professor of Literature.

* Don't try to be a Novelist directly. Try to approach the problem obliquely. For example, try to learn about the nature of programming and philosophy of programming without worrying too much about programming itself. Study programming languages "comparatively". I.e. the similarities and differences of different programming languages.

* They say the Novel (and not the Novelist) writes the Novel. Similarly, with truly creative programs, the Program writes the Program. Hence, try and make programming a subconscious skill. This requires a lot of repetitions and practice — many hours spent at the keyboard. Try and acquire as many synaptic connections in your brain by working on different programming problems. Don't just do programming for work or university courses. Start some programming hobbies. Contribute to some open source projects. [Aside, an "Yes" to the question "Do you have any side projects?" is an excellent interview question. But be sure to verify any answers. A lot of interview candidates are good at faking].

* Make sure you have dedicated time to code. In a traditional workweek of 40 yours, there are ten slots 4 hours long. Say, one before lunch and one after lunch on each working day. This works for me because I'm a "morning person". It might be afternoon and evening, or even, evening and night, if you're a night-owl. Make sure you have as many slots completely free — I.e. no meetings and no distractions. If you have, say 6–7 free 4-hour slots per week, you can be very productive. If you are an engineering manager, inspect your report's calendars to see how much dedicated time they have.

* Finally, being a Novelist is a creative process. You need energy and rest to be creative. Make sure you exercise and have enough sleep. I find my "programming creativity" severely drops when I don't have enough sleep. For the same reason, I'm not a fan of software engineers doing "all-nighters". They might be sufficient for solving known problems, but if you want a coder to be creative (i.e. solve unknown problems), make sure they get to sleep.

![Image](https://cdn-images-1.medium.com/max/800/1*0OVoliTL5CU3rZ16INvPnA.jpeg)